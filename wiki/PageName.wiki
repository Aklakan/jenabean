#summary One-sentence summary of this page.

= Introduction =

Add your content here.


= Details =


RDF is really very simple.  A property either points to another node or a literal value.  Common literals are strings, numbers, and dates, and are represented as one of the many XML schema defined types.  This maps onto Java fairly well.  A property connecting two RDF nodes can be represented by an object with a non-primitive property.  Literals can be represented by Java primitives.

One point of confusion regarding RDF is expressing multiplicity.  It's easy to declare that a person has many friends by declaring that property more than once.  The problem comes in when you want that to be ordered.  In RDF order of assertions is undefined.  The most naturaly match is Java's Collection type.





Overview
Brief audience on RDF and Jena and the need for a simple way to bind java objects to the RDF data model.
Geonames supporting example
Introduce the data set and it’s structure with a small snippet of RDF. Geonames.org hosts a large set of free geo spatial data. We’ll use a small set for the examples.
Demonstrate how the data is read and written using standard Jena, focusing on the verbosity and code needed to complete the task.
Creating Java Beans for mapping
Walk user through the process of creating Java Beans along with jenabean annotations for binding.
Demonstrate the advantages of using jenabean by comparing the smaller code size and simplicity of accomplishing the same task from the supporting example.
Finding objects
This section shows how the developer finds items using jenabean.
Creating new objects
Deep vs. shallow loads
Jenabean protects against cycles and deep loading, however, the developer can control this
Binding to SPARQL queries
SPARQL is similar to SQL. It provides queries to RDF data stores. Jenabean binds query results to java objects like Hibernate does for JDBC query results.
Demonstrate how bindings created in first part of article can be used again with query sets.