#summary Quick start guide for reading existing RDF documents with jenabean.

= Introduction =
This guide demonstrates how to read pre-existing RDF data into java objects.  This slightly more complicated (just a tiny bit) because Jenabean isn't in control of the URI's.  We are taking something created by somebody else, and mapping it to our objects.


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages

First, using Jena as usual, read the OWL ontology along with any data.  This [http://jenabean.googlecode.com/svn/trunk/src/example/GeonamesExample.java example] uses the geonames.org ontology [http://jenabean.googlecode.com/svn/trunk/src/example/geonames.owl geonames.owl]
and a set of queried data, 
[http://jenabean.googlecode.com/svn/trunk/src/example/capitals.rdf capitals.rdf]
{{{
		//prepare the jena model
		OntModel m = ModelFactory.createOntologyModel();
		m.read("file:src/example/geonames.owl");
		m.read("file:src/example/capitals.rdf");

}}} 
[http://jenabean.googlecode.com/svn/trunk/src/example/GeonamesExample.java see GeonamesExample.java]

Next, we need to tell Jenabean about our model and more importantly, how to map our javabean to a particular OWL class.

{{{
		Jenabean b = Jenabean.instance();
		b.bind(m);
		b.bind(GeonamesVocabulary.Feature).to(City.class);
}}} 
[http://jenabean.googlecode.com/svn/trunk/src/example/GeonamesExample.java see GeonamesExample.java]

`b.bind(m)` makes Jenabean aware of our model.  The next line is a little more interesting.  Here we're using a Vocabulary, generated by Jena's schemagen tool. to bind the "Feature" OntClass to our bean City.  Binding like this avoids the common pitfalls of XML, namely, typos.  Your binding won't compile unless you specify a valid OntClass and Java class.  Now whenever Jenabean sees a geonames `Feature`, it will create an instance of [http://jenabean.googlecode.com/svn/trunk/src/example/City.java City].  Now we're ready to load up all the cities within our model...

{{{
// from imports...
import static thewebsemantic.binding.Jenabean.*;
...

		Collection<City> cities = load(City.class);
		out.println("Cities in rdf triple store: " + cities.size());
}}}

`load(City.class) tells Jenabean to load all Cities from the model.  There are several other ways to do this, but this is the most simple and terse.  The rest of the work is done within the bean itself.  That's where we tell Jenabean the mappings between RDF properties and Java bean properties.  When we are driven by existing RDF, we are subject to the URLs already stored within it, therefore, we are required to indicate which method of the java bean returns the URL by using the @Uri annotation.  Also notice that we have a constructor that takes a string.

{{{
	private String id;	
	public City(String uri) {id = uri;}
	@Uri
	public String getUri() {return id;}
}}}

Properties are bound in a similar way.  We need to tell Jenabean the full URI of the property it reflects.  (Note: I'm aware that schemagen creates static OntProperty instances.  Unfortunately, java annotations do not allow classes outsite the usual primitive types.  You can use the static namespace string from schemangen + the RDF property name) 
{{{
	@RdfProperty(NS + "name")
	public String getName() {
		return name;
	}
}}}
