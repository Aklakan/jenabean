#summary Quick start guide for reading existing RDF documents with jenabean.
#labels Featured

= Introduction =
This guide demonstrates how to read pre-existing RDF data into java objects.  The code is part of the distribution and can be browsed from the project's SVN browser.  This slightly more complicated (just a tiny bit) because Jenabean isn't in control of the URI's.  We are taking something created by somebody else, and mapping it to our objects.  Most of you may just want to read the code, so here it is:
  * [http://jenabean.googlecode.com/svn/trunk/src/example/City.java City bean]
  * [http://jenabean.googlecode.com/svn/trunk/src/example/GeonamesExample.java main() example]
  * [http://jenabean.googlecode.com/svn/trunk/src/example/GeonamesExample.java see GeonamesExample.java]


= Details =

First, using Jena as usual, read the OWL ontology along with any data.  This [http://jenabean.googlecode.com/svn/trunk/src/example/GeonamesExample.java example] uses the geonames.org ontology [http://jenabean.googlecode.com/svn/trunk/src/example/geonames.owl geonames.owl]
and a set of queried data, 
[http://jenabean.googlecode.com/svn/trunk/src/example/capitals.rdf capitals.rdf]
{{{
		//prepare the jena model
		OntModel m = ModelFactory.createOntologyModel();
		m.read("file:src/example/geonames.owl");
		m.read("file:src/example/capitals.rdf");

}}} 
[http://jenabean.googlecode.com/svn/trunk/src/example/GeonamesExample.java see GeonamesExample.java]

Next, we need to tell Jenabean about our model and more importantly, how to map our javabean to a particular OWL class.

{{{
		Jenabean b = Jenabean.instance();
		b.bind(m);
		b.bind(GeonamesVocabulary.Feature).to(City.class);
}}} 
[http://jenabean.googlecode.com/svn/trunk/src/example/GeonamesExample.java see GeonamesExample.java] [http://jenabean.googlecode.com/svn/trunk/src/example/GeonamesVocabulary.java see GeonamesVocabulary.java]

`b.bind(m)` makes Jenabean aware of our model.  The next line is a little more interesting.  Here we're using a Vocabulary, generated by Jena's schemagen tool. to bind the "Feature" OntClass to our bean City.  Binding like this avoids the common pitfalls of XML, namely, typos.  Your binding won't compile unless you specify a valid OntClass and Java class.  Now whenever Jenabean sees a geonames `Feature`, it will create an instance of [http://jenabean.googlecode.com/svn/trunk/src/example/City.java City].  Now we're ready to load up all the cities within our model...

{{{
// from imports...
import static thewebsemantic.binding.Jenabean.*;
...

		Collection<City> cities = load(City.class);
		out.println("Cities in rdf triple store: " + cities.size());
}}}

`load(City.class) tells Jenabean to load all Cities from the model.  There are several other ways to do this, but this is the most simple and terse.  The rest of the work is done within the bean itself.  That's where we tell Jenabean the mappings between RDF properties and Java bean properties.  When we are driven by existing RDF, we are subject to the URLs already stored within it, therefore, we are required to indicate which method of the java bean returns the URL by using the @Uri annotation.  Also notice that we have a constructor that takes a string.

{{{
	private String id;	
	public City(String uri) {id = uri;}
	@Uri
	public String getUri() {return id;}
}}}
[http://jenabean.googlecode.com/svn/trunk/src/example/GeonamesExample.java see City.java]


Properties are bound in a similar way.  We need to tell Jenabean the full URI of the property it reflects.  (Note: I'm aware that schemagen creates static OntProperty instances.  Unfortunately, java annotations do not allow classes outsite the usual primitive types.  You can use the static namespace string from schemangen + the RDF property name) 
{{{
	@RdfProperty(NS + "name")
	public String getName() {
		return name;
	}
}}}


Back to main()...we can now iterate over the collection of cities read out of RDF.  One challenge in binding Objects is figuring out how much of the graph to read in.  If we were to read a dense graph, we'd most likely read the entire think into our Object graph.  Jenabean is therefore conservative, and refuses to load collections unless told to do so.  For each city we need to ask Jenabean to fill it with all its translations.  There is no easy way to refer to a java bean property other than it's name as a string.  Remember, with Jenabean we are mostly java focused, so the property reflects the Java bean, not the RDF property we are binding to.  (see loadDeep if you really want to recursively load the object graph).

{{{
		for (City city : cities) {
			city.fill("alternateNames");

}}}
One final note.  You are not required to extend RdfBean, however, it has some convenient features, and made the code for this example shorter.  The [http://jenabean.googlecode.com/svn/trunk/src/test/TestBean2Rdf.java test suite] is full of more verbose examples with beans that are completely raw, having no interfaces or super types.